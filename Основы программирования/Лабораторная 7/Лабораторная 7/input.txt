Лабораторная работа 4 
Шифрование текстовых файлов 
Задание
Разработать программу для шифрования и дешифрирования текста,  хранящегося в файле, основанную на методе Цезаря , но более «изощренную»: ключ, используемый для кодирования символа, будет зависеть от позиции символа в исходном тексте. Для того, чтобы шифрование и дешифрирование  можно было бы выполнять одним и тем же способом, вместо сложения кода символа с постоянным ключем (как у Цезаря) для переменных ключей используйте операцию «исключающее ИЛИ» (<код символа> ^ <ключ>) . 
При кодировании с переменным ключем один и тот же символ исходного текста будет представлен в зашифрованном тексте различными символами, что существенно усложнит «взлом шифра». Ключи должны представлять собой целые числа, определяемые путем преобразования слов кодового блокнота по следующему алгоритму:
•	ключ для k-го по порядку символа в исходном тексте вычисляется как сумма (по модулю 256) кодов символов k-го по порядку слова кодового блокнота.
•	 Если кодовый блокнот имеет слов меньше, чем количество символов в исходном тексте, то по исчерпании слов в нём перейти к первому слову и продолжить кодирование.
Целесообразно сначала на основе кодового блокнота сформировать по заданному правилу целочисленный массив ключей, который затем будет использоваться при шифровании. Получение массива ключей оформить в виде отдельной функции. 
Исследовать статистическую зависимость символов в закодированном тексте от соответствующих им символов исходного текста (сколько каких кодов одного и того же исходного символа получено) от размера кодового блокнота для заданного исходного текста. Чем меньше полученная статистическая зависимость, тем сложнее распознать текст, не зная алгоритма кодирования и текста кодового блокнота. Статистические результаты  по конкретному символу исходного текста представить в виде таблицы 16х16, по аналогии с кодировочными таблицами. Исследование и вывод таблиц результатов следует выполнять в режиме диалога, последовательно вычисляя и выводя результаты для одного запрашиваемого символа. 
Для большей достоверности статистических результатов в качестве исходного текста и кодового блокнота использовать текстовые файлы размером не менее 2 Кбайт.
Планируемое время выполнения работы - 8 часов. 
Указание.  
В программе статистические данные собирать в массиве int stat[256], из которого они распечатываются в виде таблицы 16х16. (Одна таблица для одного символа исходного текста, код которого должен вводиться с клавиатуры по запросу.) Индексы элементов массива равны кодам символов в зашифрованном тексте, в которые в результате кодирования преобразуется выбранный для сбора статистики символ исходного текста, а значения элементов массива равны числу повторных использований этого кода. (Один и тот же исходный символ в закодированном тексте представляется различными кодами в зашифрованном тексте и каждый код может использоваться несколько раз).
Для шифрования файла нет необходимости хранить весь текстовый файл в оперативной памяти. При формировании числового массива ключей следует организовать пословное чтение файла с использованием функций getline() и strtok(), а при шифровании и сборе статистики – посимвольное с помощью функций двоичного чтения данных get(ch) и put(ch). При открытии файлов устанавливать режим ios::binary. Это позволит исключить непредсказуемое влияние на процесс чтения-записи файлов управляющих кодов, которые могут появиться  в тексте в результате шифрования. 
!!! Работа состоит из трех частей и рассчитана на 12 часов (3 занятия по 4 часа). 
На первом занятии  выполняются приведенные ниже примеры программ работы с символьными строками и файлами. Особое внимание обратите на используемую последовательность шагов разработки программы и на применение библиотечных функций. Запомните: затраты времени на изучение функций библиотеки языка программирования, имеющих отношение к решаемой задаче, окупятся при разработке программы. 
Второе занятие должно завершиться тестированием шифрования и дешифрования различных текстовых файлов.
На третьем занятии выполняется сбор и вывод статистических данных по шифрованию.
Ввод-вывод строк
Для ввода-вывода строк используются как уже известные нам объекты cin и cout, так и функции, унаследованные из библиотеки С.  Рассмотрим сначала первый способ:
#include <iostream.h> 
int main()
{
 const int n = 80; 
char s[n];
cin >> s; cout << s << endl; 
return (); 
}
Как видите, строка вводится точно так же, как и переменные известных нам типов. Запустите программу и введите строку, состоящую из одного слова. Запустите про¬грамму повторно и введите строку из нескольких слов. Во втором случае выводится только первое слово. Это связано с тем, что ввод выполняется до первого пробельно¬го символа (то есть пробела, знака табуляции или символа перевода строки '\n') . Можно ввести слова входной строки в отдельные строковые переменные:
#include <iostream.h>
 int main()
{
const int n = 80;
char s[n], t[n], r[n];
cin >>s >>t >> r; cout <<s << endl << t << endl << r << endl;
return 0;
}
Если требуется ввести строку, состоящую из нескольких слов, в одну строковую переменную, используются методы getline или get класса istream, объектом кото¬рого является cin. Во втором семестре мы изучим, что такое методы клас¬са , а пока можно пользоваться ими как волшебным заклинанием, не вдумываясь в смысл. Единственное, что нам пока нужно знать, это синтаксис вызова метода — после имени объекта ставится точка, а затем пишется имя метода:
#include <iostream.h>
int main()
{ 
const int n = 80; 
char s[n];
cin.getline(s, n);  
 cout << s << endl; 
cin.get(s, n);       
cout << s << endl; 
return 0; 
}  
Метод getline считывает из входного потока n - 1 символов или менее (если сим¬вол перевода строки встретится раньше) и записывает их в строковую перемен¬ную s. Символ перевода строки  также считывается (удаляется) из входного потока, но не записывается в строковую переменную, вместо него размещается заверша¬ющий 0.